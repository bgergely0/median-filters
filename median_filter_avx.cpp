#include "omp.h"

#include "emmintrin.h"
#include "nmmintrin.h"
#include "immintrin.h"

#include "defs.h"

// sort 2 32*8 bit vector registers
#define sort_two_vectors(a, b, tmp) \
	(tmp) = _mm256_min_epu8 ((a), (b)); \
	(a) = _mm256_max_epu8 ((a), (b)); \
	(b) = (tmp);

void median_filter_avx(int imgHeight, int imgWidth, int imgWidthF,
				unsigned char *imgSrcExt, unsigned char *imgDst)
{

#if USE_OMP==1
	#pragma omp parallel for
#else
#endif
	for (int row = 0; row < imgHeight; row++)
	{
		// step with the width of one vector reg
		for (int col = 0; col < imgWidth*3; col += 32)
		{
			/*
			 * load 25 vector registers
			 * sort vector regs
			 * 32 median values are 32 outputs
			 */

			// buffer to hold 5x5 filter input pixels
			__m256i filterbuffer[25] = {};
			__m256i tmp = _mm256_set1_epi8(0);


			/*
			 *	load indexes generated by python script
			 */

#if LOOP_UNROLL == 1
unsigned char* pixel_addr;
#include "unrolled_load_loop.txt"
#else
			for (int fy = 0; fy < FILTER_H; fy++)
			{
				for (int fx = 0; fx < FILTER_W; fx++)
				{
					int filter_idx = fy * FILTER_W + fx;
					unsigned char* pixel_addr = (imgSrcExt + (row + fy) * imgWidthF * 3 + col + fx * 3);
					filterbuffer[filter_idx] = _mm256_lddqu_si256((__m256i*)(pixel_addr));
				}
			}
#endif // LOOP_UNROLL

			// manually writing which elements to sort
			// to save on execution time (loop unroll),
			// and to easier control which not to calculate
			// - as any sorting after we found the median
			// is an overhead

			/*
			 *	sort indexes generated by python script
			 */

#include "sort_indexes.txt"

			// storing 32 outputs
			_mm256_storeu_si256((__m256i*)(imgDst + row * imgWidth * 3 + col), filterbuffer[12]);
		}
	}
}
